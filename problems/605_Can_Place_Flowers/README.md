# 605. Can Place Flowers

## 題目描述

你有一個很長的花壇，一部分地塊種植了花，另一部分卻沒有。可是，花不能種植在相鄰的地塊上，它們會爭奪水源，兩者都會死去。

給你一個整數陣列 `flowerbed` 表示花壇，由若干 `0` 和 `1` 組成，其中 `0` 表示沒種植花，`1` 表示種植了花。另有一個數 `n`，能否在不打破種植規則的情況下種入 `n` 朵花？能則返回 `true`，不能則返回 `false`。

### 範例

**範例 1:**
```
輸入: flowerbed = [1,0,0,0,1], n = 1
輸出: true
解釋: 我們可以在 index 2 的位置種植一朵花。
```

**範例 2:**
```
輸入: flowerbed = [1,0,0,0,1], n = 2
輸出: false
解釋: 我們無法在不打破種植規則的情況下種入兩朵花。
```

**範例 3:**
```
輸入: flowerbed = [0], n = 1
輸出: true
解釋: 單個空位可以種植一朵花。
```

### 限制條件

- `1 <= flowerbed.length <= 2 * 10^4`
- `flowerbed[i]` 為 `0` 或 `1`
- `flowerbed` 中不存在相鄰的 `1`
- `0 <= n <= flowerbed.length`

## 解法思路

這是一個貪心算法問題。我們遍歷花壇，在每個滿足條件的空位都盡可能地種花。

### 核心思路

1. **遍歷每個位置**: 從左到右檢查每個位置
2. **檢查種植條件**: 對於位置 `i`，只有當以下條件都滿足時才能種花：
   - 當前位置為空 (`flowerbed[i] == 0`)
   - 左邊位置為空或是邊界 (`i == 0` 或 `flowerbed[i-1] == 0`)
   - 右邊位置為空或是邊界 (`i == len-1` 或 `flowerbed[i+1] == 0`)
3. **貪心策略**: 一旦找到可以種花的位置就立即種花，這樣可以最大化後續的種植機會
4. **提前返回**: 如果已經種了足夠的花就提前返回

### 算法步驟

```go
func canPlaceFlowers(flowerbed []int, n int) bool {
    count := 0
    
    for i := 0; i < len(flowerbed); i++ {
        if flowerbed[i] == 0 {
            // 檢查左邊是否為空（或是邊界）
            prevEmpty := (i == 0) || (flowerbed[i-1] == 0)
            // 檢查右邊是否為空（或是邊界）
            nextEmpty := (i == len(flowerbed)-1) || (flowerbed[i+1] == 0)
            
            if prevEmpty && nextEmpty {
                flowerbed[i] = 1  // 種花
                count++
                if count >= n {
                    return true
                }
            }
        }
    }
    
    return count >= n
}
```

### 關鍵洞察

- **邊界處理**: 邊界位置只需要檢查一側的鄰居
- **貪心正確性**: 由於花壇是線性的，越早種花越不會影響後續的選擇
- **提前結束**: 一旦達到目標數量就可以返回，不需要繼續遍歷

### 邊界情況

- **單元素陣列**: `[0]` 可以種一朵花，`[1]` 不能種花
- **兩元素陣列**: `[0,0]` 可以種一朵花，`[0,1]` 或 `[1,0]` 不能種花
- **n = 0**: 不需要種任何花，直接返回 `true`

## 複雜度分析

### 時間複雜度: O(n)
- 只需要遍歷花壇一次
- 每個位置的檢查操作都是 O(1)
- 在最壞情況下需要遍歷整個陣列
- 在最好情況下可以提前結束遍歷

### 空間複雜度: O(1)
- 只使用了常數額外空間
- 直接在原陣列上修改（也可以不修改原陣列，複雜度相同）
- 變數 `count` 和循環變數佔用 O(1) 空間

